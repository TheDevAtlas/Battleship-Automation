            try:
                try:
                    frame = detection_frame_queue.get(timeout=0.1)
                except:
                    continue
                while not detection_frame_queue.empty():
                    try:
                        frame = detection_frame_queue.get_nowait()
                    except:
                        break
                if len(templates) > 1:
                    futures = [executor.submit(process_single_template, frame, t) for t in templates]
                    matches = [future.result() for future in futures]
                else:
                    matches = [process_single_template(frame, templates[0])]
                with matches_lock:
                    current_matches.clear()
                    current_matches.extend([m for m in matches if m.get("matched")])
            except Exception as e:
                print(f"Detection thread error: {e}")
            detection_time = time.time() - detection_start
            if detection_time < detection_frame_time:
                time.sleep(detection_frame_time - detection_time)

def save_screenshot(frame_with_rectangles, matches):
    try:
        import os
        from datetime import datetime
        screenshot_dir = "Screenshots"
        if not os.path.exists(screenshot_dir):
            os.makedirs(screenshot_dir)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"detection_screenshot_{timestamp}.png"
        filepath = os.path.join(screenshot_dir, filename)
        success = cv2.imwrite(filepath, frame_with_rectangles)
        if success:
            print(f"\nSaved: {filepath}")
            print(f"Matches captured: {len(matches)}")
            for i, match in enumerate(matches):
                print(f"  [{i+1}] {match['name']} at {match['top_left']} - conf: {match['confidence']:.3f}")
        else:
            print(f"ERROR: Failed to save screenshot to {filepath}")
    except Exception as e:
        print(f"Error saving screenshot: {e}")

def check_in_game_active(matches):
    for match in matches:
        if match.get("name") == "In Game Marker":
            return True
    return False

def check_enemy_turn(matches):
    for match in matches:
        if match.get("name") == "Enemy Turn":
            return True
    return False

def check_enemy_disconnect(matches):
    for match in matches:
        if match.get("name") == "Enemy Disconnect":
            return True
    return False

def _click_center_of_match(match):
    global cached_monitor, _target_hwnd
    try:
        if cached_monitor is None:
            return
        tlx, tly = match["top_left"]
        tw, th = match["size"]
        cx = cached_monitor["left"] + int(tlx + tw/2)
        cy = cached_monitor["top"] + int(tly + th/2)
        if _target_hwnd:
            try:
                win32gui.SetForegroundWindow(_target_hwnd)
            except Exception:
                pass
        win32api.SetCursorPos((cx, cy))
        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
        time.sleep(CLICK_HOLD_SEC)
        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
        print(f"Clicked '{match['name']}' at screen ({cx},{cy})")
    except Exception as e:
        print(f"Click error for {match.get('name','?')}: {e}")

def _update_click_state(matches):
    now = time.time()
    present = {name: None for name in CLICK_TARGETS}
    # Rewards gate: only click "Exit Rewards" when "Rewards" is visible
    rewards_visible = False
    for m in matches:
        n = m.get("name")
        if n == "Rewards":
            rewards_visible = True
        if n in present:
            present[n] = m
    for name in CLICK_TARGETS:
        if _clicked_flags[name]:
            continue
        m = present[name]
        # Special case: require Rewards to be visible to allow Exit click
        if name == "Exit Rewards" and not rewards_visible:
            _visible_since[name] = None
            continue
        if m is not None:
            if _visible_since[name] is None:
                _visible_since[name] = now
            else:
                if now - _visible_since[name] >= VISIBLE_DURATION_SEC:
                    _click_center_of_match(m)
                    _clicked_flags[name] = True
                    _visible_since[name] = None
        else:
            _visible_since[name] = None

def _update_game_armed(in_game_active):
    """Arm gameplay only after both start clicks have occurred AND we have seen In-Game marker,
    plus an extra initial wait to avoid acting during opponent's first turn due to OCR lag.
    """
    global _game_armed, first_ingame_seen_ts
    if _game_armed:
        return
    if in_game_active and _clicked_flags.get("Start Game Main Menu") and _clicked_flags.get("Start Game Ready Up"):
        # Enforce extra wait after the first time we saw the in-game marker
        if first_ingame_seen_ts is None:
            return
        if (time.time() - first_ingame_seen_ts) < FIRST_INGAME_EXTRA_WAIT_SEC:
            return
        _game_armed = True
        print("[Game] Armed: start buttons clicked and In-Game detected after initial wait. Bot can act on its turn.")

def _is_game_armed():
    return _game_armed

def display_thread():
    global latest_display_frame, current_matches
    print("Display thread started")
    print("[SPACE] screenshot | [N] print next move | [ESC/Q] quit")
    display_frame_time = 1.0 / DISPLAY_FPS_TARGET
    frame_count = 0
    fps_start = time.time()
    display_fps = 0.0
    while not stop_threads.is_set():
        display_start = time.time()
        try:
            display_frame = None
            original_frame = None
            with display_frame_lock:
                if latest_display_frame is not None:
                    original_frame = latest_display_frame.copy()
                    display_frame = latest_display_frame.copy()
            if display_frame is not None and original_frame is not None:
                with matches_lock:
                    matches_to_draw = current_matches.copy()
                in_game_active = check_in_game_active(matches_to_draw)

                # Track last/first time the in-game marker was visible
                if in_game_active:
                    global last_ingame_seen_ts, first_ingame_seen_ts
                    now_ts = time.time()
                    last_ingame_seen_ts = now_ts
                    if first_ingame_seen_ts is None:
                        first_ingame_seen_ts = now_ts
                        # Optional: small log to indicate arming delay starts now
                        print(f"[Game] In-Game marker first seen. Waiting {FIRST_INGAME_EXTRA_WAIT_SEC:.1f}s before first move.")
                        try:
                            grid_tracker.reset_sunk_tracking()
                        except Exception:
                            pass

                _update_click_state(matches_to_draw)

                # Arm the game only when both start buttons are clicked and in-game is visible
                _update_game_armed(in_game_active)

                if in_game_active:
                    grid_tracker.update(original_frame)
                    display_frame = grid_tracker.render_overlay(display_frame)

                for match in matches_to_draw:
                    tw, th = match["size"]
                    br = (match["top_left"][0] + tw, match["top_left"][1] + th)
                    cv2.rectangle(display_frame, match["top_left"], br, match["color"], RECT_THICKNESS)
                    text = f'{match["name"]}: {match["confidence"]:.2f}'
                    cv2.putText(display_frame, text,
                                (match["top_left"][0], max(15, match["top_left"][1] - 6)),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.5, match["color"], 1, cv2.LINE_AA)

                if SHOW_FPS:
                    frame_count += 1
                    now = time.time()
                    if now - fps_start >= 1.0:
                        display_fps = frame_count / (now - fps_start)
                        frame_count = 0
                        fps_start = now
                    queue_size = detection_frame_queue.qsize()
                    grid_status = "ON" if in_game_active else "OFF"
                    cv2.putText(display_frame,
                               f"Display: {display_fps:.1f} FPS | Matches: {len(matches_to_draw)} | Queue: {queue_size} | Grid: {grid_status}",
                               (10, 24), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2, cv2.LINE_AA)
                    cv2.putText(display_frame,
                               "SPACE: screenshot   N: print next move   ESC/Q: quit",
                               (10, display_frame.shape[0] - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,255,255), 1, cv2.LINE_AA)

                cv2.imshow("BlueStacks Live - Fully Threaded (Auto-Click)", display_frame)

                key = cv2.waitKey(1) & 0xFF
                if key == 27 or key == ord('q'):
                    stop_threads.set()
                    break
                elif key == ord(' '):
                    save_screenshot(display_frame, matches_to_draw)
                elif key == ord('n'):
                    sug = grid_tracker.suggest_next()
                    if sug:
                        r, c, score, reason = sug
                        px, py = grid_tracker.cell_center_px(r, c)
                        print(f"Next move -> row={r}, col={c}, score={score:.1f}, px=({px},{py}) | {reason}")
                    else:
                        print("No next move: board has no UNKNOWN cells.")
        except Exception as e:
            print(f"Display thread error: {e}")

        display_time = time.time() - display_start
        if display_time < display_frame_time:
            time.sleep(display_frame_time - display_time)

def _click_screen_point(cx, cy, label="cell"):
    global _target_hwnd
    try:
        if _target_hwnd:
            try:
                win32gui.SetForegroundWindow(_target_hwnd)
            except Exception:
                pass
        win32api.SetCursorPos((int(cx), int(cy)))
        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
        time.sleep(CLICK_HOLD_SEC)
        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
        print(f"Clicked {label} at screen ({int(cx)},{int(cy)})")
        return True
    except Exception as e:
        print(f"Click error at ({cx},{cy}): {e}")
        return False

def click_cell(row, col):
    global cached_monitor
    if cached_monitor is None:
        return False
    try:
        cx, cy = grid_tracker.cell_center_px(row, col)
        sx = cached_monitor["left"] + int(cx)
        sy = cached_monitor["top"] + int(cy)
        return _click_screen_point(sx, sy, label=f"cell ({row},{col})")
    except Exception as e:
        print(f"click_cell error for ({row},{col}): {e}")
        return False

def autoplay_thread():
    if not AUTO_PLAY_ENABLED:
        return
    print("Autoplay thread started")
    pending_cell = None
    wait_until = 0.0
    while not stop_threads.is_set():
        try:
            with matches_lock:
                matches = current_matches.copy()

            in_game = check_in_game_active(matches)
            enemy_turn = check_enemy_turn(matches)

            # Must be in-game visually
            if not in_game:
                pending_cell = None
                time.sleep(0.1)
                continue

            # Require full arming: both start buttons clicked and in-game detected at least once
            if not _is_game_armed():
                time.sleep(0.1)
                continue

            now = time.time()
            if pending_cell is not None:
                if now < wait_until:
                    time.sleep(0.05)
                    continue
                r, c = pending_cell
                st = grid_tracker.state[r, c]
                if st in (HIT, SUNK):
                    print(f"Result: HIT at ({r},{c}) -> taking another shot")
                elif st == MISS:
                    print(f"Result: MISS at ({r},{c}) -> opponent's turn")
                else:
                    print(f"Result: undecided at ({r},{c}) -> assuming MISS and continuing")
                    grid_tracker.force_mark_miss(r, c)
                pending_cell = None

            # Only act on our turn, and require stability after Enemy Turn ends
            global last_enemy_turn_seen_ts, _our_turn_ready
            if enemy_turn:
                # Enemy Turn visible; mark timestamp and disarm our turn readiness
                last_enemy_turn_seen_ts = now
                _our_turn_ready = False
                time.sleep(0.15)
                continue

            # Enemy Turn not visible; require a stable absence period before first move
            if not _our_turn_ready:
                if (now - last_enemy_turn_seen_ts) < ENEMY_TURN_CLEAR_WAIT_SEC:
                    # Wait until the absence has been stable for the required window
                    time.sleep(0.1)
                    continue
                else:
                    _our_turn_ready = True

            sug = grid_tracker.suggest_next()
            if not sug:
                time.sleep(0.25)
                continue
            r, c, score, reason = sug
            if grid_tracker.state[r, c] != UNKNOWN:
                time.sleep(0.05)
                continue

            grid_tracker.mark_clicked(r, c)
            ok = click_cell(r, c)
            if ok:
                pending_cell = (r, c)
                wait_until = time.time() + WAIT_AFTER_CLICK_SEC
                # Count this as a move (a fired shot)
                global move_count
                move_count += 1
                print(f"[Moves] Fired shot #{move_count} at ({r},{c})")
                try:
                    if grid_tracker.last_used_elimination:
                        print("[Strategy] Elimination-driven shot to speed up locating ships")
                except Exception:
                    pass
            else:
                time.sleep(0.2)
        except Exception as e:
            print(f"Autoplay error: {e}")
            time.sleep(0.2)

def kill_bluestacks():
    """Force-kill common BlueStacks processes."""
    try:
        # Most reliable: taskkill (Windows)
        os.system('taskkill /F /IM HD-Player.exe >NUL 2>&1')
        os.system('taskkill /F /IM HD-Frontend.exe >NUL 2>&1')
        os.system('taskkill /F /IM Bluestacks.exe >NUL 2>&1')
        os.system('taskkill /F /IM BluestacksAppPlayer.exe >NUL 2>&1')
        print("[Exit] BlueStacks processes terminated.")
    except Exception as e:
        print(f"[Exit] Error killing BlueStacks: {e}")

def graceful_shutdown(reason=""):
    """Flip stop flag, close windows, and kill BlueStacks once."""
    if shutdown_started.is_set():
        return
    shutdown_started.set()
    print(f"\n[Exit] {reason}")
    stop_threads.set()
    # Let display thread close its window in main's finally.
    try:
        kill_bluestacks()
    except Exception as e:
        print(f"[Exit] kill_bluestacks exception: {e}")

def watchdog_thread():
    """Exit when: enough moves AND 'In Game Marker' has been gone for a while."""
    global last_ingame_seen_ts, move_count
    print("Watchdog thread started")
    while not stop_threads.is_set():
        try:
            # Immediate exit if opponent disconnect detected
            with matches_lock:
                matches_snapshot = current_matches.copy()
            if check_enemy_disconnect(matches_snapshot):
                graceful_shutdown("Opponent disconnected detected.")
                break

            now = time.time()
            # Only consider exit after we’ve fired enough shots
            if move_count >= MIN_MOVES_BEFORE_EXIT:
                # If we haven't seen the in-game marker in a while, shut down
                if last_ingame_seen_ts > 0 and (now - last_ingame_seen_ts) >= IN_GAME_LOST_GRACE_SEC:
                    graceful_shutdown(
                        f"In-game marker absent for {IN_GAME_LOST_GRACE_SEC:.1f}s after {move_count} moves."
                    )
                    break
        except Exception as e:
            print(f"Watchdog error: {e}")
        time.sleep(0.2)

def main():
    global cached_monitor, cached_window_rect, _target_hwnd
    templates = prepare_templates(SCALE_FACTOR)
    templates = [t for t in templates if t["mask_area"] >= MIN_MASK_AREA]
    print(f"Processing {len(templates)} templates at {SCALE_FACTOR}x scale")
    print(f"Targets: display {DISPLAY_FPS_TARGET} FPS | detection {DETECTION_FPS_TARGET} FPS | capture {CAPTURE_FPS_TARGET} FPS")

    win = find_bluestacks_window(WINDOW_TITLE_HINTS)
    if not win:
        raise RuntimeError("Could not find a BlueStacks window. Adjust WINDOW_TITLE_HINTS.")

    _target_hwnd = win._hWnd

    cached_window_rect = get_client_rect(win)
    left, top, right, bottom = cached_window_rect
    w = max(1, right - left)
    h = max(1, bottom - top)
    cached_monitor = {"left": left, "top": top, "width": w, "height": h}

    capture_worker = threading.Thread(target=capture_thread, args=(win,), daemon=True)
    detection_worker = threading.Thread(target=detection_thread, args=(templates,), daemon=True)
    autoplay_worker = threading.Thread(target=autoplay_thread, daemon=True)
    capture_worker.start()
    detection_worker.start()
    autoplay_worker.start()
    watchdog_worker = threading.Thread(target=watchdog_thread, daemon=True)
    watchdog_worker.start()

    try:
        display_thread()
    except KeyboardInterrupt:
        pass
    finally:
        stop_threads.set()
        cv2.destroyAllWindows()
        print("All threads stopped, windows closed")

if __name__ == "__main__":
    main()
