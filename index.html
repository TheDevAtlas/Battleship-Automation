<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battleship Grid</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }        .grid-container {
            display: grid;
            grid-template-columns: repeat(10, 45px);
            grid-template-rows: repeat(10, 45px);
            gap: 6px;
            padding: 20px;
            background-color: black;
        }        .cell {
            width: 40px;
            height: 40px;
            box-sizing: border-box;
        }
        
        .cell.smooth-transition {
            transition: background-color 0.1s ease, box-shadow 0.1s ease;
        }

        .cell.empty {
            background-color: #FFFDFF;
            -webkit-box-shadow:0px 0px 55px 2px rgba(230,0,255,0.12);
-moz-box-shadow: 0px 0px 55px 2px rgba(230,0,255,0.12);
box-shadow: 0px 0px 55px 2px rgba(230,0,255,0.12);
        }
          .cell.hit {
            background-color: #FF3A67;
        -webkit-box-shadow:0px 0px 55px 2px rgba(255,0,0,0.82);
-moz-box-shadow: 0px 0px 55px 2px rgba(255,0,0,0.82);
box-shadow: 0px 0px 55px 2px rgba(255,0,0,0.82);
        }
        
        .cell.sunk {
            background-color: #8B0000;
            -webkit-box-shadow:0px 0px 55px 2px rgba(139,0,0,0.9);
-moz-box-shadow: 0px 0px 55px 2px rgba(139,0,0,0.9);
box-shadow: 0px 0px 55px 2px rgba(139,0,0,0.9);
        }
        
        .cell.eliminated {
            background-color: #E0F0FF;
            -webkit-box-shadow:0px 0px 55px 2px rgba(173,216,230,0.15);
            -moz-box-shadow: 0px 0px 55px 2px rgba(173,216,230,0.15);
            box-shadow: 0px 0px 55px 2px rgba(173,216,230,0.15);
        }
        
        .cell.miss {
            background-color: #3a4346;
            -webkit-box-shadow:0px 0px 55px 2px rgba(71,71,71,0.12);
-moz-box-shadow: 0px 0px 55px 2px rgba(71,71,71,0.12);
box-shadow: 0px 0px 55px 2px rgba(71,71,71,0.12);
        }
          .cell.targeting-highlight {
            background-color: #FFD700;
            -webkit-box-shadow:0px 0px 55px 2px rgba(255,215,0,0.8);
            -moz-box-shadow: 0px 0px 55px 2px rgba(255,215,0,0.8);
            box-shadow: 0px 0px 55px 2px rgba(255,215,0,0.8);
        }
    </style>
</head>
<body>    <div class="grid-container" id="grid-container">
        <!-- Cells will be generated dynamically -->
    </div>    <script>        // 2D array to represent the game state
        // 0 = empty, 1 = miss, 2 = hit, 3 = sunk
        let gameBoard = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ];

        // Get container and cells array
        const gridContainer = document.getElementById('grid-container');
        let cells = [];
        
        // Create a 10x10 grid array to track cell positions
        const grid = [];
        for (let i = 0; i < 10; i++) {
            grid[i] = [];
        }

        // Function to create the grid based on the 2D array
        function createGrid() {
            gridContainer.innerHTML = '';
            cells = [];
            
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Set initial state based on gameBoard
                    updateCellClass(cell, gameBoard[row][col]);
                    
                    gridContainer.appendChild(cell);
                    cells.push(cell);
                    grid[row][col] = cell;
                }
            }
        }        // Function to update cell class based on state
        function updateCellClass(cell, state, preserveHighlight = false, preserveEliminated = false) {
            const wasHighlighted = cell.classList.contains('targeting-highlight');
            const wasEliminated = cell.classList.contains('eliminated');
            cell.classList.remove('empty', 'miss', 'hit', 'sunk', 'targeting-highlight', 'eliminated');
            switch(state) {
                case 0:
                    cell.classList.add('empty');
                    // Restore highlight if it should be preserved and cell is still empty
                    if (preserveHighlight && wasHighlighted) {
                        cell.classList.add('targeting-highlight');
                    }
                    // Restore eliminated if it should be preserved and cell is still empty
                    if (preserveEliminated && wasEliminated) {
                        cell.classList.add('eliminated');
                    }
                    break;
                case 1:
                    cell.classList.add('miss');
                    break;
                case 2:
                    cell.classList.add('hit');
                    break;
                case 3:
                    cell.classList.add('sunk');
                    break;
            }
        }        // Function to update the entire grid display
        function updateGrid(preserveHighlights = false, preserveEliminated = false) {
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = grid[row][col];
                    updateCellClass(cell, gameBoard[row][col], preserveHighlights, preserveEliminated);
                }
            }
        }// Function to update a specific cell
        function updateCell(row, col, state) {
            if (row >= 0 && row < 10 && col >= 0 && col < 10) {
                gameBoard[row][col] = state;
                const cell = grid[row][col];
                updateCellClass(cell, state);
            }
        }

        // Function to reset the board
        function resetBoard() {
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    gameBoard[row][col] = 0;
                }
            }
            updateGrid();
        }        // Function to set multiple cells at once
        function setBoardState(newBoard, preserveHighlights = false, preserveEliminated = false) {
            if (newBoard.length === 10 && newBoard[0].length === 10) {
                gameBoard = newBoard.map(row => [...row]); // Deep copy
                updateGrid(preserveHighlights, preserveEliminated);
            }
        }

        // Function to highlight targeting squares
        function highlightTargetingSquares(squares) {
            // Clear any existing highlights
            clearTargetingHighlights();
            
            // Add highlights to specified squares
            squares.forEach(square => {
                const [row, col] = square;
                if (row >= 0 && row < 10 && col >= 0 && col < 10) {
                    const cell = grid[row][col];
                    // Only highlight if it's an empty cell
                    if (gameBoard[row][col] === 0) {
                        cell.classList.add('targeting-highlight');
                    }
                }
            });
        }

        // Function to clear targeting highlights
        function clearTargetingHighlights() {
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    grid[row][col].classList.remove('targeting-highlight');
                }
            }
        }
        
        // Function to highlight eliminated squares
        function highlightEliminatedSquares(squares) {
            // Clear any existing eliminated highlights
            clearEliminatedHighlights();
            
            // Add eliminated class to specified squares
            squares.forEach(square => {
                const [row, col] = square;
                if (row >= 0 && row < 10 && col >= 0 && col < 10) {
                    const cell = grid[row][col];
                    // Only highlight if it's an empty cell
                    if (gameBoard[row][col] === 0) {
                        cell.classList.add('eliminated');
                    }
                }
            });
        }
        
        // Function to clear eliminated highlights
        function clearEliminatedHighlights() {
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    grid[row][col].classList.remove('eliminated');
                }
            }
        }

        // Listen for keyboard events
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                if (!isRandomizing) {
                    startRandomizing();
                } else {
                    stopRandomizing();
                }
            } else if (event.code === 'KeyR') {
                // Press 'R' to reset the board
                event.preventDefault();
                stopRandomizing();
                resetBoard();
            } else if (event.code === 'KeyT') {
                // Press 'T' to test random updates
                event.preventDefault();
                testRandomUpdates();
            } else if (event.code === 'KeyG') {
                // Press 'G' to generate a single random grid
                event.preventDefault();
                const newBoard = generateRandomGrid();
                smoothUpdateGrid(newBoard);
            }
        });// Function to test random updates
        function testRandomUpdates() {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const row = Math.floor(Math.random() * 10);
                    const col = Math.floor(Math.random() * 10);
                    const state = Math.floor(Math.random() * 3);
                    updateCell(row, col, state);
                }, i * 500);
            }
        }

        // Variables for grid randomization
        let isRandomizing = false;
        let randomizeInterval;

        // Function to generate a random battleship grid
        function generateRandomGrid() {
            const newBoard = Array(10).fill(null).map(() => Array(10).fill(0));
            const ships = [5, 4, 3, 3, 2]; // Ship sizes
            
            // Place ships
            for (let shipSize of ships) {
                let placed = false;
                let attempts = 0;
                
                while (!placed && attempts < 100) {
                    const horizontal = Math.random() < 0.1;
                    const row = Math.floor(Math.random() * 10);
                    const col = Math.floor(Math.random() * 10);
                    
                    if (canPlaceShip(newBoard, row, col, shipSize, horizontal)) {
                        placeShip(newBoard, row, col, shipSize, horizontal);
                        placed = true;
                    }
                    attempts++;
                }
            }
            
            // Add random misses (15-25 random miss cells)
            const missCount = Math.floor(Math.random() * 11) + 15; // 15-25 misses
            for (let i = 0; i < missCount; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const row = Math.floor(Math.random() * 10);
                    const col = Math.floor(Math.random() * 10);
                    
                    if (newBoard[row][col] === 0) {
                        newBoard[row][col] = 1; // Miss
                        break;
                    }
                    attempts++;
                }
            }
            
            return newBoard;
        }

        // Function to check if a ship can be placed
        function canPlaceShip(board, row, col, size, horizontal) {
            if (horizontal) {
                if (col + size > 10) return false;
                for (let i = 0; i < size; i++) {
                    if (board[row][col + i] !== 0) return false;
                    // Check surrounding cells for other ships
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const newRow = row + dr;
                            const newCol = col + i + dc;
                            if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                                if (board[newRow][newCol] === 2) return false;
                            }
                        }
                    }
                }
            } else {
                if (row + size > 10) return false;
                for (let i = 0; i < size; i++) {
                    if (board[row + i][col] !== 0) return false;
                    // Check surrounding cells for other ships
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const newRow = row + i + dr;
                            const newCol = col + dc;
                            if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                                if (board[newRow][newCol] === 2) return false;
                            }
                        }
                    }
                }
            }
            return true;
        }

        // Function to place a ship
        function placeShip(board, row, col, size, horizontal) {
            if (horizontal) {
                for (let i = 0; i < size; i++) {
                    board[row][col + i] = 2; // Hit
                }
            } else {
                for (let i = 0; i < size; i++) {
                    board[row + i][col] = 2; // Hit
                }
            }
        }        // Function to smoothly update the grid
        function smoothUpdateGrid(newBoard) {
            // Update the game board and cell classes
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    gameBoard[row][col] = newBoard[row][col];
                    const cell = grid[row][col];
                    updateCellClass(cell, newBoard[row][col]);
                }
            }
        }

        // Function to start randomizing the grid
        function startRandomizing() {
            if (isRandomizing) return;
            
            isRandomizing = true;
            randomizeInterval = setInterval(() => {
                const newBoard = generateRandomGrid();
                smoothUpdateGrid(newBoard);
            }, 1100); // Every 1 second
        }

        // Function to stop randomizing the grid
        function stopRandomizing() {
            if (!isRandomizing) return;
            
            isRandomizing = false;
            if (randomizeInterval) {
                clearInterval(randomizeInterval);
                randomizeInterval = null;
            }        }

        // Server-Sent Events connection for Python control
        let eventSource = null;
        
        function connectSSE() {
            eventSource = new EventSource('http://localhost:8080/events');
            
            eventSource.onopen = () => {
                console.log('Connected to Python backend via SSE');
            };
            
            eventSource.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                if (data.type === 'board_update') {
                    // Update the board with new state from Python, preserving highlights and eliminated squares
                    setBoardState(data.board, true, true);
                } else if (data.type === 'game_over') {
                    console.log(`Game over in ${data.moves} moves!`);
                    clearTargetingHighlights();
                    clearEliminatedHighlights();
                } else if (data.type === 'targeting_highlights') {
                    // Enable smooth transitions for video mode
                    cells.forEach(cell => cell.classList.add('smooth-transition'));
                    // Highlight suspected targeting squares
                    highlightTargetingSquares(data.squares);
                } else if (data.type === 'clear_highlights') {
                    // Clear targeting highlights
                    clearTargetingHighlights();
                } else if (data.type === 'eliminated_squares') {
                    // Highlight eliminated squares in light blue for parity hunt
                    highlightEliminatedSquares(data.squares);
                }
            };
            
            eventSource.onerror = (error) => {
                console.error('SSE error:', error);
                // SSE will automatically try to reconnect
            };
        }
        
        // Initialize the grid
        createGrid();
        
        // Connect to SSE when page loads
        connectSSE();
    </script>
</body>
</html>