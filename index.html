<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battleship Grid</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }        .grid-container {
            display: grid;
            grid-template-columns: repeat(10, 45px);
            grid-template-rows: repeat(10, 45px);
            gap: 6px;
            padding: 20px;
            background-color: black;
        }        .cell {
            width: 40px;
            height: 40px;
            box-sizing: border-box;
        }

        .cell.empty {
            background-color: #FFFDFF;
            -webkit-box-shadow:0px 0px 55px 2px rgba(230,0,255,0.52);
-moz-box-shadow: 0px 0px 55px 2px rgba(230,0,255,0.52);
box-shadow: 0px 0px 55px 2px rgba(230,0,255,0.52);
        }
        
        .cell.hit {
            background-color: #FF3A67;
        -webkit-box-shadow:0px 0px 55px 2px rgba(255,0,0,0.82);
-moz-box-shadow: 0px 0px 55px 2px rgba(255,0,0,0.82);
box-shadow: 0px 0px 55px 2px rgba(255,0,0,0.82);
        }        .cell.miss {
            background-color: #3a4346;
            -webkit-box-shadow:0px 0px 55px 2px rgba(71,71,71,0.52);
-moz-box-shadow: 0px 0px 55px 2px rgba(71,71,71,0.52);
box-shadow: 0px 0px 55px 2px rgba(71,71,71,0.52);
        }

        .cell.animate {
            animation: spiralGrow 0.8s ease-in-out forwards;
        }        @keyframes spiralGrow {
            0% {
                transform: scale(0);
            }
            70% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes boardUpdate {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }        .cell.updating {
            animation: boardUpdate 0.3s ease-in-out forwards;
        }

        .cell.transitioning {
            transition: all 0.5s ease-in-out;
        }
    </style>
</head>
<body>    <div class="grid-container" id="grid-container">
        <!-- Cells will be generated dynamically -->
    </div>    <script>
        // 2D array to represent the game state
        // 0 = empty, 1 = miss, 2 = hit
        let gameBoard = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ];

        // Get container and cells array
        const gridContainer = document.getElementById('grid-container');
        let cells = [];
        
        // Create a 10x10 grid array to track cell positions
        const grid = [];
        for (let i = 0; i < 10; i++) {
            grid[i] = [];
        }

        // Function to create the grid based on the 2D array
        function createGrid() {
            gridContainer.innerHTML = '';
            cells = [];
            
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Set initial state based on gameBoard
                    updateCellClass(cell, gameBoard[row][col]);
                    
                    gridContainer.appendChild(cell);
                    cells.push(cell);
                    grid[row][col] = cell;
                }
            }
        }

        // Function to update cell class based on state
        function updateCellClass(cell, state) {
            cell.classList.remove('empty', 'miss', 'hit');
            switch(state) {
                case 0:
                    cell.classList.add('empty');
                    break;
                case 1:
                    cell.classList.add('miss');
                    break;
                case 2:
                    cell.classList.add('hit');
                    break;
            }
        }

        // Function to update the entire grid display
        function updateGrid() {
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = grid[row][col];
                    updateCellClass(cell, gameBoard[row][col]);
                    
                    // Add updating animation
                    cell.classList.add('updating');
                    setTimeout(() => {
                        cell.classList.remove('updating');
                    }, 300);
                }
            }
        }

        // Function to update a specific cell
        function updateCell(row, col, state) {
            if (row >= 0 && row < 10 && col >= 0 && col < 10) {
                gameBoard[row][col] = state;
                const cell = grid[row][col];
                updateCellClass(cell, state);
                
                // Add updating animation
                cell.classList.add('updating');
                setTimeout(() => {
                    cell.classList.remove('updating');
                }, 300);
            }
        }

        // Function to reset the board
        function resetBoard() {
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    gameBoard[row][col] = 0;
                }
            }
            updateGrid();
        }

        // Function to set multiple cells at once
        function setBoardState(newBoard) {
            if (newBoard.length === 10 && newBoard[0].length === 10) {
                gameBoard = newBoard.map(row => [...row]); // Deep copy
                updateGrid();
            }
        }

        // Calculate spiral order starting from center
        function getSpiralOrder() {
            const center = { x: 4.5, y: 4.5 }; // Center of 10x10 grid
            const order = [];
            
            // Get all cell positions with their distances from center
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    const distance = Math.sqrt(Math.pow(i - center.y, 2) + Math.pow(j - center.x, 2));
                    const angle = Math.atan2(i - center.y, j - center.x);
                    order.push({
                        cell: grid[i][j],
                        distance: distance,
                        angle: angle,
                        x: j,
                        y: i
                    });
                }
            }
            
            // Sort by distance first, then by angle for spiral effect
            order.sort((a, b) => {
                if (Math.abs(a.distance - b.distance) < 0.1) {
                    return a.angle - b.angle;
                }
                return a.distance - b.distance;
            });
            
            return order;
        }        let spiralOrder;

        // Animation function
        function animateSpiral() {
            // Reset all animations first
            cells.forEach(cell => {
                cell.classList.remove('animate');
                cell.style.transform = 'scale(0)';
            });

            // Animate each cell with delay
            spiralOrder.forEach((item, index) => {
                setTimeout(() => {
                    item.cell.classList.add('animate');
                }, index * 10); // 0.01 seconds = 10ms delay between each tile
            });
        }        // Listen for keyboard events
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                if (!isRandomizing) {
                    animateSpiral();
                    // Start randomizing after spiral animation
                    setTimeout(() => {
                        startRandomizing();
                    }, 800); // Wait for spiral animation to complete
                } else {
                    stopRandomizing();
                }
            } else if (event.code === 'KeyR') {
                // Press 'R' to reset the board
                event.preventDefault();
                stopRandomizing();
                resetBoard();
            } else if (event.code === 'KeyT') {
                // Press 'T' to test random updates
                event.preventDefault();
                testRandomUpdates();
            } else if (event.code === 'KeyG') {
                // Press 'G' to generate a single random grid
                event.preventDefault();
                const newBoard = generateRandomGrid();
                smoothUpdateGrid(newBoard);
            }
        });// Function to test random updates
        function testRandomUpdates() {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const row = Math.floor(Math.random() * 10);
                    const col = Math.floor(Math.random() * 10);
                    const state = Math.floor(Math.random() * 3);
                    updateCell(row, col, state);
                }, i * 500);
            }
        }

        // Variables for grid randomization
        let isRandomizing = false;
        let randomizeInterval;

        // Function to generate a random battleship grid
        function generateRandomGrid() {
            const newBoard = Array(10).fill(null).map(() => Array(10).fill(0));
            const ships = [5, 4, 3, 3, 2]; // Ship sizes
            
            // Place ships
            for (let shipSize of ships) {
                let placed = false;
                let attempts = 0;
                
                while (!placed && attempts < 100) {
                    const horizontal = Math.random() < 0.5;
                    const row = Math.floor(Math.random() * 10);
                    const col = Math.floor(Math.random() * 10);
                    
                    if (canPlaceShip(newBoard, row, col, shipSize, horizontal)) {
                        placeShip(newBoard, row, col, shipSize, horizontal);
                        placed = true;
                    }
                    attempts++;
                }
            }
            
            // Add random misses (15-25 random miss cells)
            const missCount = Math.floor(Math.random() * 11) + 15; // 15-25 misses
            for (let i = 0; i < missCount; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const row = Math.floor(Math.random() * 10);
                    const col = Math.floor(Math.random() * 10);
                    
                    if (newBoard[row][col] === 0) {
                        newBoard[row][col] = 1; // Miss
                        break;
                    }
                    attempts++;
                }
            }
            
            return newBoard;
        }

        // Function to check if a ship can be placed
        function canPlaceShip(board, row, col, size, horizontal) {
            if (horizontal) {
                if (col + size > 10) return false;
                for (let i = 0; i < size; i++) {
                    if (board[row][col + i] !== 0) return false;
                    // Check surrounding cells for other ships
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const newRow = row + dr;
                            const newCol = col + i + dc;
                            if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                                if (board[newRow][newCol] === 2) return false;
                            }
                        }
                    }
                }
            } else {
                if (row + size > 10) return false;
                for (let i = 0; i < size; i++) {
                    if (board[row + i][col] !== 0) return false;
                    // Check surrounding cells for other ships
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const newRow = row + i + dr;
                            const newCol = col + dc;
                            if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                                if (board[newRow][newCol] === 2) return false;
                            }
                        }
                    }
                }
            }
            return true;
        }

        // Function to place a ship
        function placeShip(board, row, col, size, horizontal) {
            if (horizontal) {
                for (let i = 0; i < size; i++) {
                    board[row][col + i] = 2; // Hit
                }
            } else {
                for (let i = 0; i < size; i++) {
                    board[row + i][col] = 2; // Hit
                }
            }
        }

        // Function to smoothly update the grid
        function smoothUpdateGrid(newBoard) {
            // Add transition class to all cells
            cells.forEach(cell => {
                cell.classList.add('transitioning');
            });

            // Update the game board and cell classes
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    gameBoard[row][col] = newBoard[row][col];
                    const cell = grid[row][col];
                    updateCellClass(cell, newBoard[row][col]);
                }
            }

            // Remove transition class after animation completes
            setTimeout(() => {
                cells.forEach(cell => {
                    cell.classList.remove('transitioning');
                });
            }, 500);
        }

        // Function to start randomizing the grid
        function startRandomizing() {
            if (isRandomizing) return;
            
            isRandomizing = true;
            randomizeInterval = setInterval(() => {
                const newBoard = generateRandomGrid();
                smoothUpdateGrid(newBoard);
            }, 1100); // Every 1 second
        }

        // Function to stop randomizing the grid
        function stopRandomizing() {
            if (!isRandomizing) return;
            
            isRandomizing = false;
            if (randomizeInterval) {
                clearInterval(randomizeInterval);
                randomizeInterval = null;
            }
        }// Initialize the grid
        createGrid();
        
        // Initialize spiral order after grid is created
        spiralOrder = getSpiralOrder();
        
        // Show cells immediately (you can comment this out if you want them hidden initially)
        cells.forEach(cell => {
            cell.style.transform = 'scale(1)';
        });
        
        // Optionally, animate the initial appearance
        // animateSpiral();
    </script>
</body>
</html>